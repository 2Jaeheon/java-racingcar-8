# 구현 기능 목록

> 구현해야 할 기능들의 목록입니다.
> 요구사항에 맞춰 각 기능을 커밋 단위로 설정하였습니다.
>
> 각 기능은 `feat` 태그를 통해 커밋되었습니다.

- [X] 자동차 이름을 입력받는다.
- [X] 시도 횟수를 입력받는다.
- [X] 콘솔에 메시지를 출력한다.
- [X] 입력받은 문자열을 쉼표로 파싱한다.
- [X] 무작위 값을 사용해 이동 여부를 결정한다
- [X] 위치를 증가할 자동차 선택를 선택한다.
- [X] 자동차의 위치를 증가시킨다.
- [X] 자동차 경기 진행 상황 출력한다.
- [X] 우승자를 결정한다.
- [X] 우승자를 출력한다.

# 추가 개선 사항 목록

> 기능이라고 보기 어려운, 코드의 품질 향상을 위한 체크리스트입니다.
>
> 각 항목에 관해 체크하기 위한 용도로 작성되었습니다.

- [ ] 단위 테스트 작성
- [ ] 통합 테스트 작성
- [ ] 리펙토링
    - [ ] Loose Coupling & High Cohesion (느슨한 결합과 높은 응집도)를 지켰는가?
    - [ ] Tell, Don't Ask 원칙을 지켰는가?
    - [ ] 각 클래스 및 메서드의 책임을 명확하게 분리했는가?
    - [ ] 캡슐화가 잘 지켜졌는가?
    - [ ] YAGNI(You Ain't Gonna Need It) 원칙을 지켰는가?
    - [ ] KISS (Keep It Simple, Stupid) 원칙을 지켰는가?
    - [ ] DRY (Don't Repeat Yourself) 원칙을 지켰는가?

> 다음은 1주차 피드백과 요구사항으로부터 추가된 코드 품질 향상 체크리스트입니다.

- [ ] 커밋 컨벤션을 잘 지켰는가?
- [ ] 코드 컨벤션을 잘 지켰는가?
- [ ] 메서드가 한 가지 일만 하고 있는가?
- [ ] 변수명, 메서드명이 명확한가?
- [ ] indent(들여쓰기)는 2칸인가?
- [ ] 불필요한 주석은 없는가?
- [ ] 공백 라인을 의미 있게 사용했는가?

# 추가 커밋 사항

> 추가적으로 리펙토링 및 수정 사항이 발생하는 경우 아래의 커밋 컨벤션에 맞춰
> 추가적인 커밋 사항이 작성됩니다.

커밋은 다음의 [AngularJS Git Commit Message Conventions](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)에 맞추어
진행하였습니다.<br>
위의 커밋 컨벤션을 준수하기 위해 아래와 같은 태그를 사용하였습니다.

- feat (feature)
- fix (bug fix)
- docs (documentation)
- style (formatting, missing semi colons, …)
- refactor
- test (when adding missing tests)
- chore (maintain)

# 개인적 2주차 목표

- 빠르게 구현하고, 객체지향의 특성을 적극 활용해 리펙토링한다.
- 객체지향이 무엇이고 왜 좋으며, 객체지향을 통해 달성해야 하는 목표는 무엇인지 생각한다.
- 객체지향의 본질에 대해 고민하고, 객체지향 설계 원칙을 적용한다.
- 예외 처리에 대해 고민하고 적용한다.
- 테스트 코드 작성에 대해 고민하고 적용한다.
- 성장에 대해 고민하고, 나만의 성장 지표를 세운다.
- 좋은 설계에 대해 고민하고, 어떤 부분에 대해서 좋은 설계인지를 고민한다.

# 설계

설계는 최소한의 설계로 시작해서 빠르게 기능을 구현해서 동작하는 프로그램을 만든 뒤,
점진적으로 리팩토링하는 방식을 채택했습니다.

![img.png](resources/domainModelV1.png)
> 위의 다이어그램은 제출 전까지 계속해서 수정됩니다.<br>
> 최종 제출 시점의 다이어그램이 최종 설계 다이어그램이 됩니다.<br>
> 설계 다이어그램은 [excalidraw](https://excalidraw.com/)로 작성되었습니다.

### 설계 방법

- 시스템의 책임을 식별한 뒤 책임을 수행할 객체를 도출했습니다.
- 객체의 책임으로부터 필요한 메시지를 식별했습니다.
- 메시지를 객체에 할당하는 방식으로 설계를 진행했습니다.

---

# 어떻게 리펙토링 했는지에 관한 고민

> 리펙토링 과정에서 고민했던 점들을 기록합니다.
> 리펙토링 커밋마다 해당 리펙토링에 관한 고민을 기록합니다.

### 리펙토링 1 - Input/Output 분리

기존의 GameConsole 클래스에서 입력과 출력을 모두 담당했지만, 책임이 과하게 많아 분리할 필요가 있었습니다.
따라서 InputView와 OutputView 클래스를 새로 만들어 입력과 출력을 각각 담당하도록 했습니다.

### 리펙토링 2 - Cars 일급 컬렉션 클래스 도입

GameConsole 클래스에서는 List<Car>를 통해서 어떻게 우승자를 찾고, 어떻게 차를 움직이는 지 모든 방법들을 알고 있습니다.
이는 GameConsole이 수행해야 하는 책임이 아니며, 책임을 분리할 필요가 있었습니다.
따라서 GameConsole이 도메인 객체에 무엇을 할지 명령만 해야한다(Tell, Don't Ask)는 객체지향 설계 원칙을 지키기 위해 Race 클래스를 도입했습니다.

즉, 경주를 진행하는 책임을 Race 객체가 담당하도록 수정하였습니다.
이를 통해서 GameConsole이 데이터를 가져와 조립하지 않고 처리할 수 있었습니다.

### 리펙토링 3 - inputConverter에서 입력값 검증을 수행

기존의 코드에서는 GameConsole에서 입력값에 대한 검증 로직을 수행했지만, 이는 책임이 과하게 많아 분리할 필요가 있었습니다.
따라서 InputConverter 클래스에서 입력값에 대한 검증 로직을 수행하도록 수정했습니다. 또한 입력에 관해서 에외 처리를 진행하였습니다.

### 리펙토링 4 - 예외 처리

예외에 관해서 상수로 처리하였으며, 예외를 전파해서 GameConsole에서 try-catch로 처리하도록 수정했습니다.
예외 메시지는 상수화해서 관리하였으며, 따로 예외 클래스를 만들 필요는 없다고 판단하여 일반 `throw new IllegalArgumentException()` 방식을 사용했습니다.
예외 클래스를 만드는 것은 YAGNI 원칙에 어긋난다고 생각하였습니다.

### 리펙토링 5 - 결합도를 낮추자

도메인 내부에서 View관련 문자열을 생성하던 부분(getStatus())을 제거하고, 출력 포맷을 생성하는 책임을 GameConsole로 이전했습니다.
이를 통해 도메인에는 내부 로직에만 집중할 수 있으며, View와의 결합을 제거할 수 있었음. 이를 getCars()로 변경하여 처리하였습니다.

또한 Race의 내부 컬렉션을 보호하기 위해서 생성자에서 바로 cars를 할당하지 않고 new ArrayList<>(cars)를 통해서 복사본을 할당하도록 수정했습니다.
이를 통해서 외부에서 내부 컬렉션을 변경하지 못하도록 보호할 수 있었습니다. 하지만, getCars() 메서드에서 cars를 반환하면 인스턴스를 반환하기 때문에
외부에서 내부 컬렉션을 변경할 수 있습니다. 따라서 getCars() 메서드는 불변 리스트를 반환하도록 `List.copyOf(cars)`를 사용했습니다.

### 리펙토링 6 - 의존성 주입

GameConsole에서 InputView, OutputView, InputConverter, MoveStrategy를 직접 생성하지 않고
생성자 주입을 통해서 외부에서 주입받도록 수정했습니다. 이를 통해서 결합도를 낮추고, 테스트하기 쉬운 구조로 변경했습니다.
따라서 AppConfig 클래스에서 객체를 생성하고 주입하는 방식으로 구현했습니다.

### 리펙토링 7 - OutputView에 출력 포맷팅 책임 추가

위의 리펙토링 5에서 getCars()를 통해서 Controller에서 출력 포맷팅을 담당하도록 변경했지만, 이는 SRP 원칙을 위반하는 것 아닌가 고민했습니다.
따라서 출력 포매팅을 OutputView에서 담당하는 것이 더 적절하다고 생각하였습니다. 하지만 데이터를 반환할 때에는 DTO를 사용하는 것이 좋다고 판단했습니다.
따라서 CarStatusDTO를 도입하여 Car의 이름과 위치 정보를 담아서 OutputView에서 출력 포맷팅을 담당하도록 수정했습니다.
DTO를 만들지 않는다면 OutputView가 도메인 모델과 강하게 결합되기 때문에 유지보수성 측면에서 좋지 않다고 생각했습니다.

# 고민

#### 1. Car에서 Getter가 존재하는데, Tell Don't Ask 원칙을 위반하는 것은 아닌가?

Car에는 다양한 Getter 메서드가 존재하기 때문에 Tell Don't Ask 원칙을 위반하는 것 아닌가 고민했습니다.<br>
하지만 우승자를 판별하기 위해서는 하나의 경주의 여러 개의 차가 존재해야 하며, Car 하나로는 우승자를 판별할 수 없다고 생각했습니다.
또한, Race는 레이스를 진행해야 하는 책임이 있는데, 이 과정에서 Car에게 데이터를 요청하는 것이 불가피하다고 생각했습니다.

#### 2. Race에 여러가지의 책임이 존재하는 것 아닌가?

Race 객체를 도입하면서 경주를 진행하는 책임과 우승자를 판별하는 책임을 모두 가지게 됨으로서 SRP(단일 책임 원칙)를 위반하는 것 아닌가 고민했습니다.
하지만, Race는 "경주를 진행한다" 라는 하나의 책임을 가진다고 생각했습니다.

또한, SRP 원칙을 책임을 하나만 져야하는 것이 아닌 "클래스를 변경하는 이유는 단 하나여야 한다" 라는 의미로
정확하게 해석할 수 있었습니다. 따라서 Race는 변경의 이유가 "경주를 진행한다"이기 때문에 SRP 원칙을 위반하지 않는다고 생각했습니다.

#### 3. 컨트롤러의 역할이 정확히 무엇일까?

구현한 GameConsole은 컨트롤러의 역할을 수행한다고 생각했습니다. 그렇다면 Controller의 역할이 무엇일까 고민했습니다.
왜냐하면 Race라는 객체를 도입하면서 race.start() 하나로 경주를 처리하면 Controller의 역할이 너무 단순해지는 것 아닌가 싶었기 때문입니다.
하지만, 이 경우에는 각 레이스의 상황을 출력하기 위해서는 도메인 모델 내부에서 입/출력과 강하게 결합된다고 생각했습니다.
따라서 Controller는 흐름을 제어하고 도메인과 뷰 사이를 오케스트레이션 하는 역할이라는 것을 깨달았습니다.

#### 4. inputConverter에 대해서도 인터페이스를 도입하는 것이 좋을까?

초기에는 확장성을 고려하여 inputConverter에 대해서도 인터페이스를 도입해야 하나 고민했습니다. 하지만, 현재 요구사항에서는 확장성이 필요하지 않다고 판단했습니다.
또한 인터페이스를 도입함으로써 오히려 코드가 복잡해지며 YAGNI 원칙에 어긋난다고 생각했습니다. 따라서 inputConverter에 대해서는 인터페이스를 도입하지 않았습니다.
하지만, MoveStrategy에 대해서는 정책이며, 확장과 변경 가능성이 매우 높다고 판단하여 인터페이스를 도입했습니다.

#### 5. 예외 처리는 어디서 해야하지?

예외 처리를 어디서 해야할지 고민했습니다. 특히, 도메인 모델 내부에서 예외가 발생하는 경우에 대해서 고민이 많았습니다.
이 경우 도메인 모델 내부에서 예외를 처리하는 것보다 예외를 전파해서 컨트롤러에서 처리하는 것이 좋다고 생각했습니다.
왜냐하면 도메인 모델은 비즈니스 로직에 집중해야 하며, 예외 처리는 애플리케이션의 흐름 제어와 관련이 깊기 때문입니다.
따라서 도메인 모델 내부에서는 예외를 던지고, GameConsole에서 try-catch로 처리하도록 했습니다.

추가로 Enum을 통해서 예외 메시지를 관리해서 처리하는 방향에 대해서도 고민해보았으나, 이는 객체간의 결합도를 증가시킨다고 생각했습니다.
또한 모든 클래스들이 enum 객체에 의존하기 때문에 오히려 유지보수가 어려워질 수 있다고 판단했습니다. 따라서 예외 메시지는 상수로 관리하는 방향으로 결정했습니다.

#### 6. DTO를 도입해야 할까??

각 레이스마다 출력을 하기 위해서는 출력 형식을 만든 뒤 출력을 해야합니다. 이 과정에서 출력 형식을 만드는 것을 어떤 객체에 할당을 해야하는지에 대해서 고민했습니다.
도메인 모델에 출력 형식을 만드는 책임을 할당하는 것은 SRP 원칙을 위반한다고 생각했습니다. 또한 Controller에서 처리하는 것은 Controller가 과한 책임을 가지게 된다고 생각했습니다.
따라서 OutputView에 출력 형식을 만드는 책임을 할당하는 것이 가장 적절하다고 생각했습니다. 하지만, OutputView가 도메인 모델과 강하게 결합되는 문제점이 발생했습니다.
따라서 DTO를 도입하여 도메인 모델과 OutputView 사이의 결합도를 낮추는 방향으로 결정했습니다.

#### 7. Car의 move(moveStrategy)를 통해서 이동을 처리하는 것이 적절한가?

Car의 move(moveStrategy)를 통해서 이동을 처리하는 것이 적절한가 고민했습니다.
왜냐하면 인자가 없이 move()만 하도록 Car 객체를 생성할 때 MoveStrategy를 주입받도록 하는 것이 더 객체지향적이라고 생각했기 때문입니다.
그러면 Race와 Strategy가 결합이 되지 않는다고 생각했습니다.
하지만, 이 경우에는 테스트를 하기가 어려워진다고 생각했습니다. 따라서 moveStrategy를 인자로 받는 것이 테스트하기 더 용이하다고 판단했습니다.